Anleitung:
- immer wenn ein Guh/Device aus einem Guh/Plugin instanziert wird,
wird eine (neue, sofern noch nicht vorhanden) COLLECTION erstellt
  - ist eine COLLECTION mit angegebener ID bereits vorhanden,
    so werden neue DATA (entsprechend der SIGNAL.id) nach den alten
    DATA hinzugefügt
  - ist eine COLLECTION mit angegebener ID nicht vorhanden,
    so wird eine neue COLLECTION erstellt und die DATA danach
    abgespeichert
- löscht man ein Guh/Device (in Guh), so bleiben die verbundenen
COLLECTIONs erhalten

{
  "MongoDB:uuid": { //<-- Collection (A) von GloveLeft. Für GloveRight gibt es eine eigene Collection
    "id":"a62d4a74-e2ed-11e6", //<-- Collection-Id
    "collector": {
      "id":"a62d4a74-e2ed-11e6", //<-- gibt nur den MOM/Collector-Type an. Die Devices haben keine IDs
      "guh": {
        "deviceID":"a62d4a74-e2ed-11e6", //<-- Guh-Device von dem die Daten stammen
        "pluginID":"a62d4a74-e2ed-11e6" //<-- Guh-Plugin von dem die Daten stammen
      }
    },
    "signals": [
      {
        "id":"a62d4a74-e2ed-11e6", //<-- kommt von der Plattform, kann man das beim Kompilieren mitgeben?
        "slug":"rfid", //<-- nur eine Hilfe beim Auslesen
        "data": [
          {
            "value":"000000000000",
            "user": {
              "id":"" //<-- nur eine Behelfsmöglichkeit um den User-Kontext anzugeben
            },
            "stamp": {
              "id": "0",
              "unixtime": "1481890593" //<-- Beide Signals wurden zum selben Zeitpunkt (A) empfangen
            }
          }
        ]
      },
      {
        "id":"a62d4a74-e2ed-11e6",
        "slug":"grasp.sensor-1",
        "data": [
          {
            "value":125,
            "user": {
              "id":""
            },
            "stamp": {
              "id": "0",
              "unixtime": "1481890593" //<-- Beide Signals wurden zum selben Zeitpunkt (A) empfangen
            }
          }
        ]
      }
    ]
  }
}

//------------- NUR IDEEN -------------

// Alternative zu signals->data
"data": [
  {
    "stamp": {
      "id": "Integer[>0]" //<-- das wird eine sehr Hohe Zahl! Übertragungsrate 50Hz, 10Min lang = 50*60*10 = 30k
      "unixtime": "String[10]>'1481890593'" //<-- welchen Zeitstempel braucht die TU und welcher ist leicht zu programmieren?
    },
    "signal": {
      "id":""
    },
    "value":""
  }
]

"data": {
  "stamp": {
    "id": "Integer[>0]" //<-- das wird eine sehr Hohe Zahl! Übertragungsrate 50Hz, 10Min lang = 50*60*10 = 30k
    "unixtime": "String[10]>'1481890593'" //<-- welchen Zeitstempel braucht die TU und welcher ist leicht zu programmieren?
  },
  "rfid":"String[000000000000|xxxxxxxxxxxx]", //=rfid (siehe 'ser2file.py')
  "grasp": {
     "sensor-1":"Integer[0,1023]", //=myo (siehe 'ser2file.py')
  },
  "acceleration": { //Beschleunigung im Raum
    "x":"Float[a,b]", //=ax (siehe 'ser2file.py')
    "y":"Float[a,b]", //=ay (siehe 'ser2file.py')
    "z":"Float[a,b]" //=az (siehe 'ser2file.py')
  },
  "rotation": { //Lage im Raum
    "y": "Float[a,b]", //=ey (siehe 'ser2file.py')
    "x": "Float[a,b]", //=ex (siehe 'ser2file.py')
    "z": "Float[a,b]" //=ez (siehe 'ser2file.py')
  },
  "interface": { //am Handschuh angebrachte Eingabeinstrumente
    "userInputButton":"Boolean[true|false]", //='key' (siehe 'ser2file.py')
    "handIsInGlove":"Boolean[true|false]", //='capsens' (siehe 'ser2file.py')
    "additionalSwitch":"Boolean[true|false]" //='sw' (siehe 'ser2file.py')
  },
  "calculated": { //auf dem Mikrocontroller oder durch das Programm gefolgerte Werte
    "isSameRFIDTag":"Boolean[true|false]" //='lastnr' (siehe 'ser2file.py')
  }
}
