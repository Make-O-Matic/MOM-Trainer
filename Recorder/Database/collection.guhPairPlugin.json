Anleitung:
- immer wenn ein Guh/Device aus einem Guh/Plugin instanziert wird,
wird eine (neue, sofern noch nicht vorhanden) COLLECTION erstellt
  - ist eine COLLECTION mit angegebener ID bereits vorhanden,
    so werden neue DATA (entsprechend der SIGNAL.id) nach den alten
    DATA hinzugefügt
  - ist eine COLLECTION mit angegebener ID nicht vorhanden,
    so wird eine neue COLLECTION erstellt und die DATA danach
    abgespeichert
- löscht man ein Guh/Device (in Guh), so bleiben die verbundenen
COLLECTIONs erhalten

collectionID-gloveLeft: UUID <-- wird von der Plattform automatisch generiert
userId: UUID <-- wird beim Erstellen des Device vom User angegeben (NEW: !!!muss zur Laufzeit geändert werden können)
mac-adress-gloveLeft: MAC-Adresse des Bluetooth-Moduls <-- wird vom User auf der Plattform festgelegt
mac-adress-gloveRight: MAC-Adresse des Bluetooth-Moduls <-- wird vom User auf der Plattform festgelegt




{
  "COL: CollectionId": { //<-- Collection (A) von GloveLeft. Für GloveRight gibt es eine eigene Collection
    "_id":"Mongo:uuid",
    "id": "a62d4a74-e2ed-11e6", //<-- Collection-Id
    "collector": {
      "id": "C001",
      "type": {
          "id":"a62d4a74-e2ed-11e6" //<-- gibt nur den MOM/Collector-Type an. Die Devices haben keine IDs
      }
    },
    "guh": {
      "deviceID":"a62d4a74-e2ed-11e6", //<-- Guh-Device von dem die Daten stammen
      "pluginID":"a62d4a74-e2ed-11e6" //<-- Guh-Plugin von dem die Daten stammen
    },
    "signal": {
      "id":"a62d4a74-e2ed-11e6", //<-- kommt von der Plattform, kann man das beim Kompilieren mitgeben?
      "slug":"rfid", //<-- nur eine Hilfe beim Auslesen
    },
    "data": {
      "value":"000000000000",
      "user": {
        "id":"" //<-- nur eine Behelfsmöglichkeit um den User-Kontext anzugeben
      },
      "stamp": {
        "unixtime": "1481890593"
      }
    }
  }
}

//------------- NUR IDEEN -------------

// Alternative zu signals->data
"data": [
  {
    "stamp": {
      "id": "Integer[>0]" //<-- das wird eine sehr Hohe Zahl! Übertragungsrate 50Hz, 10Min lang = 50*60*10 = 30k
      "unixtime": "String[10]>'1481890593'" //<-- welchen Zeitstempel braucht die TU und welcher ist leicht zu programmieren?
    },
    "signal": {
      "id":""
    },
    "value":""
  }
]

"data": {
  "stamp": {
    "id": "Integer[>0]" //<-- das wird eine sehr Hohe Zahl! Übertragungsrate 50Hz, 10Min lang = 50*60*10 = 30k
    "unixtime": "String[10]>'1481890593'" //<-- welchen Zeitstempel braucht die TU und welcher ist leicht zu programmieren?
  },
  "rfid":"String[000000000000|xxxxxxxxxxxx]", //=rfid (siehe 'ser2file.py')
  "grasp": {
     "sensor-1":"Integer[0,1023]", //=myo (siehe 'ser2file.py')
  },
  "acceleration": { //Beschleunigung im Raum
    "x":"Float[a,b]", //=ax (siehe 'ser2file.py')
    "y":"Float[a,b]", //=ay (siehe 'ser2file.py')
    "z":"Float[a,b]" //=az (siehe 'ser2file.py')
  },
  "rotation": { //Lage im Raum
    "y": "Float[a,b]", //=ey (siehe 'ser2file.py')
    "x": "Float[a,b]", //=ex (siehe 'ser2file.py')
    "z": "Float[a,b]" //=ez (siehe 'ser2file.py')
  },
  "interface": { //am Handschuh angebrachte Eingabeinstrumente
    "userInputButton":"Boolean[true|false]", //='key' (siehe 'ser2file.py')
    "handIsInGlove":"Boolean[true|false]", //='capsens' (siehe 'ser2file.py')
    "additionalSwitch":"Boolean[true|false]" //='sw' (siehe 'ser2file.py')
  },
  "calculated": { //auf dem Mikrocontroller oder durch das Programm gefolgerte Werte
    "isSameRFIDTag":"Boolean[true|false]" //='lastnr' (siehe 'ser2file.py')
  }
}
